 class{trackDisposable(D){const y=new Error("Potentially leaked disposable").stack;setTimeout(()=>{D[E]||console.log(y)},3e3)}setParent(D,y){if(D&&D!==n.None)try{D[E]=!0}catch{}}markAsDisposed(D){if(D&&D!==n.None)try{D[E]=!0}catch{}}markAsSingleton(D){}})}function w(E){return L?.trackDisposable(E),E}function I(E){L?.markAsDisposed(E)}function b(E,D){L?.setParent(E,D)}function S(E,D){if(!!L)for(const y of E)L.setParent(y,D)}function C(E){return L?.markAsSingleton(E),E}e.markAsSingleton=C;function r(E){return typeof E.dispose=="function"&&E.dispose.length===0}e.isDisposable=r;function h(E){if(m.Iterable.is(E)){const D=[];for(const y of E)if(y)try{y.dispose()}catch(T){D.push(T)}if(D.length===1)throw D[0];if(D.length>1)throw new AggregateError(D,"Encountered errors while disposing of store");return Array.isArray(E)?[]:E}else if(E)return E.dispose(),E}e.dispose=h;function i(E){for(const D of E)r(D)&&D.dispose();return[]}e.disposeIfDisposable=i;function f(...E){const D=u(()=>h(E));return S(E,D),D}e.combinedDisposable=f;function u(E){const D=w({dispose:(0,t.once)(()=>{I(D),E()})});return D}e.toDisposable=u;class c{constructor(){this._toDispose=new Set,this._isDisposed=!1,w(this)}dispose(){this._isDisposed||(I(this),this._isDisposed=!0,this.clear())}get isDisposed(){return this._isDisposed}clear(){if(this._toDispose.size!==0)try{h(this._toDispose)}finally{this._toDispose.clear()}}add(D){if(!D)return D;if(D===this)throw new Error("Cannot register a disposable on itself!");return b(D,this),this._isDisposed?c.DISABLE_DISPOSED_WARNING||console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack):this._toDispose.add(D),D}}e.DisposableStore=c,c.DISABLE_DISPOSED_WARNING=!1;class n{constructor(){this._store=new c,w(this),b(this._store,this)}dispose(){I(this),this._store.dispose()}_register(D){if(D===this)throw new Error("Cannot register a disposable on itself!");return this._store.add(D)}}e.Disposable=n,n.None=Object.freeze({dispose(){}});class l{constructor(){this._isDisposed=!1,w(this)}get value(){return this._isDisposed?void 0:this._value}set value(D){this._isDisposed||D===this._value||(this._value?.dispose(),D&&b(D,this),this._value=D)}clear(){this.value=void 0}dispose(){this._isDisposed=!0,I(this),this._value?.dispose(),this._value=void 0}clearAndLeak(){const D=this._value;return this._value=void 0,D&&b(D,null),D}}e.MutableDisposable=l;class s{constructor(D){this._disposable=D,this._counter=1}acquire(){return this._counter++,this}release(){return--this._counter===0&&this._disposable.dispose(),this}}e.RefCountedDisposable=s;class a{constructor(){this.dispose=()=>{},this.unset=()=>{},this.isset=()=>!1,w(this)}set(D){let y=D;return this.unset=()=>y=void 0,this.isset=()=>y!==void 0,this.dispose=()=>{y&&(y(),y=void 0,I(this))},this}}e.SafeDisposable=a;class o{constructor(){this.references=new Map}acquire(D,...y){let T=this.references.get(D);T||(T={counter:0,object:this.createReferencedObject(D,...y)},this.references.set(D,T));const{object:A}=T,P=(0,t.once)(()=>{--T.counter===0&&(this.destroyReferencedObject(D,T.object),this.references.delete(D))});return T.counter++,{object:A,dispose:P}}}e.ReferenceCollection=o;class g{constructor(D){this.referenceCollection=D}async acquire(D,...y){const T=this.referenceCollection.acquire(D,...y);try{return{object:await T.object,dispose:()=>T.dispose()}}catch(A){throw T.dispose(),A}}}e.AsyncReferenceCollection=g;class d{constructor(D){this.object=D}dispose(){}}e.ImmortalReference=d;function v(E){const D=new c;try{E(D)}finally{D.dispose()}}e.disposeOnReturn=v;class p{constructor(){this._store=new Map,this._isDisposed=!1,w(this)}dispose(){I(this),this._isDisposed=!0,this.clearAndDisposeAll()}clearAndDisposeAll(){if(!!this._store.size)try{h(this._store.values())}finally{this._store.clear()}}has(D){return this._store.has(D)}get(D){return this._store.get(D)}set(D,y,T=!1){this._isDisposed&&console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack),T||this._store.get(D)?.dispose(),this._store.set(D,y)}deleteAndDispose(D){this._store.get(D)?.dispose(),this._store.delete(D)}[Symbol.iterator](){return this._store[Symbol.iterator]()}}e.DisposableMap=p}),define(ae[155],le([1,0]),function(J,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.LinkedList=void 0;class t{constructor(L){this.element=L,this.next=t.Undefined,this.prev=t.Undefined}}t.Undefined=new t(void 0);class m{constructor(){this._first=t.Undefined,this._last=t.Undefined,this._size=0}get size(){return this._size}isEmpty(){return this._first===t.Undefined}clear(){let L=this._first;for(;L!==t.Undefined;){const k=L.next;L.prev=t.Undefined,L.n