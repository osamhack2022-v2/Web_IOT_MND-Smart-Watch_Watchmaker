++]=128|(s&63)>>>0):(n[l++]=240|(s&1835008)>>>18,n[l++]=128|(s&258048)>>>12,n[l++]=128|(s&4032)>>>6,n[l++]=128|(s&63)>>>0),l>=64&&(this._step(),l-=64,this._totalLen+=64,n[0]=n[64+0],n[1]=n[64+1],n[2]=n[64+2]),l}digest(){return this._finished||(this._finished=!0,this._leftoverHighSurrogate&&(this._leftoverHighSurrogate=0,this._buffLen=this._push(this._buff,this._buffLen,65533)),this._totalLen+=this._buffLen,this._wrapUp()),f(this._h0)+f(this._h1)+f(this._h2)+f(this._h3)+f(this._h4)}_wrapUp(){this._buff[this._buffLen++]=128,h(this._buff,this._buffLen),this._buffLen>56&&(this._step(),h(this._buff));const n=8*this._totalLen;this._buffDV.setUint32(56,Math.floor(n/4294967296),!1),this._buffDV.setUint32(60,n%4294967296,!1),this._step()}_step(){const n=u._bigBlock32,l=this._buffDV;for(let D=0;D<64;D+=4)n.setUint32(D,l.getUint32(D,!1),!1);for(let D=64;D<320;D+=4)n.setUint32(D,r(n.getUint32(D-12,!1)^n.getUint32(D-32,!1)^n.getUint32(D-56,!1)^n.getUint32(D-64,!1),1),!1);let s=this._h0,a=this._h1,o=this._h2,g=this._h3,d=this._h4,v,p,E;for(let D=0;D<80;D++)D<20?(v=a&o|~a&g,p=1518500249):D<40?(v=a^o^g,p=1859775393):D<60?(v=a&o|a&g|o&g,p=2400959708):(v=a^o^g,p=3395469782),E=r(s,5)+v+d+p+n.getUint32(D*4,!1)&4294967295,d=g,g=o,o=r(a,30),a=s,s=E;this._h0=this._h0+s&4294967295,this._h1=this._h1+a&4294967295,this._h2=this._h2+o&4294967295,this._h3=this._h3+g&4294967295,this._h4=this._h4+d&4294967295}}e.StringSHA1=u,u._bigBlock32=new DataView(new ArrayBuffer(320))}),define(ae[1223],le([1,0,57,104]),function(J,e,t,m){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha1Hex=void 0;async function R(L){if(globalThis?.crypto?.subtle){const k=t.VSBuffer.fromString(L,{dontUseNodeBuffer:!0}).buffer,w=await globalThis.crypto.subtle.digest({name:"sha-1"},k);return(0,m.toHexString)(w)}else{const k=new m.StringSHA1;return k.update(L),k.digest()}}e.sha1Hex=R}),define(ae[403],le([1,0,990,104]),function(J,e,t,m){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.LcsDiff=e.MyArray=e.Debug=e.stringDiff=e.StringDiffSequence=void 0;class R{constructor(r){this.source=r}getElements(){const r=this.source,h=new Int32Array(r.length);for(let i=0,f=r.length;i<f;i++)h[i]=r.charCodeAt(i);return h}}e.StringDiffSequence=R;function L(C,r,h){return new S(new R(C),new R(r)).ComputeDiff(h).changes}e.stringDiff=L;class k{static Assert(r,h){if(!r)throw new Error(h)}}e.Debug=k;class w{static Copy(r,h,i,f,u){for(let c=0;c<u;c++)i[f+c]=r[h+c]}static Copy2(r,h,i,f,u){for(let c=0;c<u;c++)i[f+c]=r[h+c]}}e.MyArray=w;var I;(function(C){C[C.MaxDifferencesHistory=1447]="MaxDifferencesHistory"})(I||(I={}));class b{constructor(){this.m_changes=[],this.m_originalStart=1073741824,this.m_modifiedStart=1073741824,this.m_originalCount=0,this.m_modifiedCount=0}MarkNextChange(){(this.m_originalCount>0||this.m_modifiedCount>0)&&this.m_changes.push(new t.DiffChange(this.m_originalStart,this.m_originalCount,this.m_modifiedStart,this.m_modifiedCount)),this.m_originalCount=0,this.m_modifiedCount=0,this.m_originalStart=1073741824,this.m_modifiedStart=1073741824}AddOriginalElement(r,h){this.m_originalStart=Math.min(this.m_originalStart,r),this.m_modifiedStart=Math.min(this.m_modifiedStart,h),this.m_originalCount++}AddModifiedElement(r,h){this.m_originalStart=Math.min(this.m_originalStart,r),this.m_modifiedStart=Math.min(this.m_modifiedStart,h)